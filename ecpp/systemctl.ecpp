<#
 #
 # Copyright (C) 2015 - 2020 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file systemctl.ecpp
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Jim Klimov <EvgenyKlimov@Eaton.com>
 * \brief  Provide Users ability to manipulate with some specified services
 */
 #><%pre>
#include <cxxtools/serializationinfo.h>
#include <cxxtools/jsondeserializer.h>

#include <stdexcept>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <fty_common_macros.h>
#include <fty_common_rest_helpers.h>
#include <fty_common_rest_audit_log.h>
#include <fty/process.h>
#include <fty/string-utils.h>

bool
is_GET_operation (const std::string& operation)
{
    if (operation.compare ("list") == 0
        || operation.compare ("status") == 0)
    {
        return true;
    }
    return false;
}

bool
is_POST_operation (const std::string& operation)
{
    if (operation.compare ("start") == 0
        || operation.compare ("stop") == 0
        || operation.compare ("restart") == 0
        || operation.compare ("enable") == 0
        || operation.compare ("disable") == 0)
    {
        return true;
    }
    return false;
}

bool
systemctl_service_status (const std::string& service_name, std::string& load, std::string& active, std::string& unit_file, std::string& sub)
{
    fty::Process proc("sudo", {"systemctl", "show", service_name,
                       "-p", "LoadState", "-p", "ActiveState", "-p", "UnitFileState", "-p", "SubState"});
    proc.run();

    auto rv = proc.wait();

    if (!rv || *rv != 0) {
        std::string message;
        message = "`sudo systemctl show " + service_name + " -p LoadState -p ActiveState "
                  "-p UnitFileState -p SubState` failed. Return value = '" + std::to_string (*rv) + "', stderr = '" + proc.readAllStandardError() + "'.";
        log_error ("%s", message.c_str ());
        return false;
    }

    std::vector<std::string> tokens = fty::split(proc.readAllStandardOutput(), "\n");
    for (const auto& item: tokens) {
        if (item.empty ()) {
            continue;
        }
        std::size_t found = item.find ("=");
        if (found == std::string::npos) {
            return false;
        }
        std::string key = item.substr (0, found);
        std::string value  = item.substr (found + 1, std::string::npos);

        if (key.compare ("LoadState") == 0) {
            load = value;
        }
        else if (key.compare ("ActiveState") == 0) {
            active = value;
        }
        else if (key.compare ("UnitFileState") == 0) {
            unit_file = value;
        }
        else if (key.compare ("SubState") == 0) {
            sub = value;
        }
        else {
            return false;
        }
    }
    return true;
}
</%pre>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Dashboard, "R"},
            {BiosProfile::Admin,     "RE"}
            };
    std::string audit_msg;
    if (request.getMethod () == "POST")
        audit_msg = std::string ("Request EXECUTE systemctl FAILED");
    CHECK_USER_PERMISSIONS_OR_DIE_AUDIT (PERMISSIONS, audit_msg.empty () ? nullptr : audit_msg.c_str ());

    // check method
    if (request.getMethod () != "GET" && request.getMethod () != "POST")
        http_die ("method-not-allowed", request.getMethod ().c_str ());

    std::string checked_operation;
    std::string checked_service_name;

    // check operation
    {
        std::string operation = request.getArg ("operation");
        std::transform (operation.begin (), operation.end (), operation.begin (), ::tolower);
        if (!is_GET_operation (operation) && !is_POST_operation (operation)) {
            std::string param = TRANSLATE_ME ("operation");
            std::string expected = TRANSLATE_ME ("status/list/enable/disable/start/stop/restart");
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s FAILED", operation.c_str ());
            }
            http_die ("request-param-bad", param.c_str (), operation.c_str (), expected.c_str ());
        }

        if (request.getMethod () == "GET" && is_POST_operation (operation)) {
            std::string msg = TRANSLATE_ME ("an operation allowed for GET method:") + "status/list.";
            std::string param = TRANSLATE_ME ("operation");
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s FAILED", operation.c_str ());
            }
            http_die ("request-param-bad", param.c_str (), operation.c_str (), msg.c_str ());

        }
        if (request.getMethod () == "POST" && is_GET_operation (operation)) {
            std::string param = TRANSLATE_ME ("operation");
            std::string expected = TRANSLATE_ME ("an operation allowed for POST method: enable/disable/start/stop/restart.");
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s FAILED", operation.c_str ());
            }
            http_die ("request-param-bad", param.c_str (), operation.c_str (), expected.c_str ());
        }
        checked_operation = operation;
    }
    log_info ("checked_operation: '%s'", checked_operation.c_str ());

    // check service name
    {
        std::string service_name;
        if (request.getMethod () == "GET")
        {
            service_name = request.getArg ("service_name");
        }
        else
        if (request.getMethod () == "POST")
        {
            if (request.getBody ().empty ()) {
                std::string msg = TRANSLATE_ME ("Expected json document") + "  { \"service_name\" : \"<service_name>\" }." + TRANSLATE_ME (" Received empty request document.");
                if (request.getMethod () == "POST") {
                    log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), service_name.c_str ());
                }
                http_die ("bad-request-document", msg.c_str ());
            }
            try {
                std::stringstream input (request.getBody (), std::ios_base::in);
                cxxtools::JsonDeserializer deserializer (input);
                cxxtools::SerializationInfo si;
                deserializer.deserialize (si);
                if (si.category () != cxxtools::SerializationInfo::Object) {
                    throw cxxtools::SerializationError ("Received document's root is not json object.");
                }
                si.getMember ("service_name") >>= service_name;
            }
            catch (const cxxtools::SerializationError& e) {
                std::string message;
                message.assign ("Expected json document { \"service_name\" : \"<service_name>\" }. ").append (e.what ());
                if (request.getMethod () == "POST") {
                    log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), service_name.c_str ());
                }
                http_die ("bad-request-document", message.c_str ());
            }
            catch (const std::exception& e) {
                std::string message;
                message.assign ("Exception caught: ").append (e.what ());
                log_error ("%s", message.c_str ());
                std::string err =  TRANSLATE_ME ("Exception caught. Please check logs for more details.");
                if (request.getMethod () == "POST") {
                    log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), service_name.c_str ());
                }
                http_die ( "internal-error", err.c_str ());
            }
        }

        std::string expected = TRANSLATE_ME ("one of service names that can be obtained through systemctl/list call");
        if (service_name.empty () && checked_operation != "list") {
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), service_name.c_str ());
            }
            http_die ("request-param-bad", "service_name", service_name.c_str (), expected.c_str ());
        }

        if (!systemctl_valid_service_name (service_name)) {
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), service_name.c_str ());
            }
            http_die ("request-param-bad", "service_name", service_name.c_str (), expected.c_str ());
        }

        checked_service_name.assign (service_name);
    }
    log_info ("checked_service_name: '%s'", checked_service_name.c_str ());

    if (checked_operation == "list") {
        // NOTE: This is a passive operation (meaning it does not call the
        // "systemctl" program), which just formats whatever we have in the
        // pre-initialized list of service names allowed for manipulation
        // via webserver.

        std::string message;
        message.assign (
            "{\n"
            "\t\"systemctl_services\" : [\n");

        std::vector <std::string> v;
        systemctl_get_service_names (v);

        bool first = true;
        for (const auto& element : v) {
            message.append (first ? "\t\t\"" : ",\t\t\"").
                    append (element).
                    append ("\"\n");
            if (first)
                first = false;
        }

        message.append (
            "\t]\n"
            "}");
        reply.out () << message;
        if (request.getMethod () == "POST") {
            log_info_audit ("Request EXECUTE systemctl %s %s SUCCESS", checked_operation.c_str (), checked_service_name.c_str ());
        }
        return HTTP_OK;
    }
    else
    if (checked_operation == "status") {
        std::string ActiveState, SubState, LoadState, UnitFileState;
        if (!systemctl_service_status (checked_service_name, LoadState, ActiveState, UnitFileState, SubState)) {
            std::string err =  TRANSLATE_ME ("Executing systemctl failed. Please check logs for more details.");
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), checked_service_name.c_str ());
            }
            http_die ("internal-error", err.c_str ());
        }

        std::string message;
        message.assign (
            "{\n"
            "\t\"" + checked_service_name + "\" : {\n" +
            "\t\t\"ActiveState\"\t:\t\"" + ActiveState + "\",\n"
            "\t\t\"SubState\"\t:\t\"" + SubState + "\",\n"
            "\t\t\"LoadState\"\t:\t\"" + LoadState + "\",\n"
            "\t\t\"UnitFileState\"\t:\t\"" + UnitFileState + "\"\n"
            "\t}\n"
            "}");
        reply.out () << message;
        return HTTP_OK;
    }

    // remaining operations are POST only

    // MVY's request
    if (checked_service_name == "tntnet@bios")
    {
        reply.out () << "{}";
        return HTTP_OK;
    }

    {
        fty::Process proc("sudo", {"systemctl", checked_operation, checked_service_name});
        proc.run();
        auto rv = proc.wait();

        if (!rv || *rv != 0) {
            std::string message;
            // Use our wrapper from PATH of the web-server,
            // so allowing management of only our services
            message = "`sudo systemctl " + checked_operation + " " + checked_service_name  + "'.";
            log_error ("%s", message.c_str ());
            std::string err =  TRANSLATE_ME ("Executing systemctl failed. Please check logs for more details.");
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), checked_service_name.c_str ());
            }
            http_die ("internal-error", err.c_str ());
        }

        std::string ActiveState, SubState, LoadState, UnitFileState;
        if (!systemctl_service_status (checked_service_name, LoadState, ActiveState, UnitFileState, SubState)) {
            std::string err =  TRANSLATE_ME ("Executing systemctl failed. Please check logs for more details.");
            if (request.getMethod () == "POST") {
                log_error_audit ("Request EXECUTE systemctl %s %s FAILED", checked_operation.c_str (), checked_service_name.c_str ());
            }
            http_die ("internal-error", err.c_str ());
        }
        std::string message;
        message.assign (
            "{\n"
            "\t\"" + checked_service_name + "\" : {\n" +
            "\t\t\"ActiveState\"\t:\t\"" + ActiveState + "\",\n"
            "\t\t\"SubState\"\t:\t\"" + SubState + "\",\n"
            "\t\t\"LoadState\"\t:\t\"" + LoadState + "\",\n"
            "\t\t\"UnitFileState\"\t:\t\"" + UnitFileState + "\"\n"
            "\t}\n"
            "}");
        reply.out () << message;
        if (request.getMethod () == "POST") {
            log_info_audit ("Request EXECUTE systemctl %s %s SUCCESS", checked_operation.c_str (), checked_service_name.c_str ());
        }
        return HTTP_OK;
    }
</%cpp>
